package com.example.coding.matrix.leetcode.hard;

/**
 * You are given a network of n nodes represented as an n x n adjacency matrix graph,
 * where the ith node is directly connected to the jth node if graph[i][j] == 1.
 *
 * Some nodes initial are initially infected by malware. Whenever two nodes are directly connected,
 * and at least one of those two nodes is infected by malware, both nodes will be infected by malware.
 * This spread of malware will continue until no more nodes can be infected in this manner.
 *
 * Suppose M(initial) is the final number of nodes infected with malware in the entire network after
 * the spread of malware stops. We will remove exactly one node from initial.
 *
 * Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to
 * minimize M(initial), return such a node with the smallest index.
 *
 * Note that if a node was removed from the initial list of infected nodes, it might still be infected
 * later due to the malware spread.
 */
public class MinimizeMalwareSpread {

  /**
   * 0->1->2->3 ad 4
   *
   * @param graph
   * @param initial
   * @return
   */
  public static int minMalwareSpread(int[][] graph, int[] initial) {
    int rows = graph.length;
    int cols = graph[0].length;

    UnionFind uf = new UnionFind(rows);

    for (int i=0; i< rows; i++) {
      for (int j=0; j< cols; j++) {
        if (graph[i][j] == 1) {
          int p1 = uf.findParent(i);
          int p2 = uf.findParent(j);
          if (p1 != p2) {
            uf.merge(p1,p2);
          }
        }
      }
    }

    System.out.println(uf);

    int[] infected = new int[rows]; // How may are infected initially from the same group.

    for (int initialInfected : initial) {
      int infectedParent = uf.findParent(initialInfected);
      infected[infectedParent] ++;
    }

    int ans = -1;
    int maxSize = -1;

    for (int initialInfected : initial) {
      //Now if infected count =1 in a group then only consider
      int infectedParent = uf.findParent(initialInfected);
      if (infected[infectedParent] == 1 && uf.getSize()[infectedParent] >= maxSize) {

        if (uf.getSize()[infectedParent] == maxSize) {
          ans = Math.min(ans, initialInfected); // If equal size then retrun lowest number
        } else {
          ans = initialInfected;
        }

        maxSize = uf.getSize()[infectedParent];
      }
    }

    return ans;
  }

  public static void main(String[] args) {
    int[][] graph = {{1,1,0,0,0},{1,1,1,0,0},{0,1,1,1,0},{0,0,1,1,0},{0,0,0,0,1}};
    minMalwareSpread(graph, new int[] {0,1});
  }
}

class UnionFind {
  int n;
  int[] parent;
  int[] size;

  public UnionFind(int n) {
    this.n = n;
    this.parent = new int[n];
    this.size = new int[n];

    for (int i=0; i<n; i++) {
      parent[i] = i;
      size[i] = 1;
    }
  }

  public int findParent(int node) {
    if (parent[node] == node) {
      return node;
    }

    return parent[node] = findParent(parent[node]);
  }

  public int[] getSize() {
    return size;
  }

  public void merge(int node1, int node2) {
    if (size[node1] > size[node2]) {
      parent[node2] = node1;
      size[node1]+= size[node2];
    } else {
      parent[node1] = node2;
      size[node2] += size[node1];
    }
  }
}
